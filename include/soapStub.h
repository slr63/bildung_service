/* soapStub.h
   Generated by gSOAP 2.8.104 for bildung.h

gSOAP XML Web services tools
Copyright (C) 2000-2020, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include <vector>
#define SOAP_NAMESPACE_OF_ns1	"http://www.lsb-niedersachsen.de/bildungsportal/api/"

#ifndef soapStub_H
#define soapStub_H
#include "stdsoap2.h"
#if GSOAP_VERSION != 208104
# error "GSOAP VERSION 208104 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumeration Types                                                          *
 *                                                                            *
\******************************************************************************/


/* bildung.h:218 */
#ifndef SOAP_TYPE_ns1__SearchType
#define SOAP_TYPE_ns1__SearchType (33)
/* ns1:SearchType */
enum ns1__SearchType {
	ns1__SearchType__Exact = 0,
	ns1__SearchType__Start = 1,
	ns1__SearchType__Middle = 2,
	ns1__SearchType__End = 3
};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes, Structs and Unions                                                *
 *                                                                            *
\******************************************************************************/

class ns1__EventFilter;	/* bildung.h:166 */
class ns1__EventBase;	/* bildung.h:170 */
class ns1__EventFee;	/* bildung.h:174 */
class ns1__Address;	/* bildung.h:176 */
class ns1__WorkshopTimeslot;	/* bildung.h:178 */
class ns1__Workshop;	/* bildung.h:180 */
class ns1__EventRegistration;	/* bildung.h:182 */
class ns1__EventRegistrationEvent;	/* bildung.h:184 */
class ns1__EventRegistrationWarning;	/* bildung.h:186 */
class ns1__KeyValue;	/* bildung.h:188 */
class _ns1__dumpTableFields;	/* bildung.h:190 */
class _ns1__dumpTableFieldsResponse;	/* bildung.h:192 */
class _ns1__getAllEvents;	/* bildung.h:194 */
class _ns1__getAllEventsResponse;	/* bildung.h:196 */
class _ns1__getSingleEvent;	/* bildung.h:198 */
class _ns1__getSingleEventResponse;	/* bildung.h:200 */
class _ns1__register;	/* bildung.h:202 */
class _ns1__registerResponse;	/* bildung.h:204 */
class ns1__EventMini;	/* bildung.h:168 */
class ns1__Event;	/* bildung.h:172 */
struct __ns1__dumpTableFields;	/* bildung.h:1060 */
struct __ns1__getAllEvents;	/* bildung.h:1130 */
struct __ns1__getSingleEvent;	/* bildung.h:1200 */
struct __ns1__register;	/* bildung.h:1270 */
struct __ns1__dumpTableFields_;	/* bildung.h:1340 */
struct __ns1__getAllEvents_;	/* bildung.h:1410 */
struct __ns1__getSingleEvent_;	/* bildung.h:1480 */
struct __ns1__register_;	/* bildung.h:1550 */

/* bildung.h:166 */
#ifndef SOAP_TYPE_ns1__EventFilter
#define SOAP_TYPE_ns1__EventFilter (13)
/* complex XML schema type 'ns1:EventFilter': */
class SOAP_CMAC ns1__EventFilter {
      public:
        /// Optional element 'ns1:OrganizerId' of XML schema type 'xsd:unsignedInt'
        unsigned int *OrganizerId;
        /// Optional element 'ns1:VenueId' of XML schema type 'xsd:unsignedInt'
        unsigned int *VenueId;
        /// Optional element 'ns1:KSBNumber' of XML schema type 'xsd:string'
        std::string *KSBNumber;
        /// Optional element 'ns1:LSBNumber' of XML schema type 'xsd:string'
        std::string *LSBNumber;
        /// Optional element 'ns1:SportRegion' of XML schema type 'xsd:unsignedInt'
        unsigned int *SportRegion;
        /// Optional element 'ns1:OnlyVisible' of XML schema type 'xsd:boolean'
        bool *OnlyVisible;
        /// Optional element 'ns1:OnlyWithEducationalLeave' of XML schema type 'xsd:boolean'
        bool *OnlyWithEducationalLeave;
        /// Optional element 'ns1:Title' of XML schema type 'xsd:string'
        std::string *Title;
        /// Optional element 'ns1:TitleSearchType' of XML schema type 'ns1:SearchType'
        enum ns1__SearchType *TitleSearchType;
        /// Optional element 'ns1:TitleAddition' of XML schema type 'xsd:string'
        std::string *TitleAddition;
        /// Optional element 'ns1:TitleAdditionSearchType' of XML schema type 'ns1:SearchType'
        enum ns1__SearchType *TitleAdditionSearchType;
        /// Optional element 'ns1:Subtitle' of XML schema type 'xsd:string'
        std::string *Subtitle;
        /// Optional element 'ns1:SubtitleSearchType' of XML schema type 'ns1:SearchType'
        enum ns1__SearchType *SubtitleSearchType;
        /// Optional element 'ns1:SubtitleAddition' of XML schema type 'xsd:string'
        std::string *SubtitleAddition;
        /// Optional element 'ns1:SubtitleAdditionSearchType' of XML schema type 'ns1:SearchType'
        enum ns1__SearchType *SubtitleAdditionSearchType;
        /// Optional element 'ns1:Category' of XML schema type 'xsd:string'
        std::string *Category;
        /// Optional element 'ns1:CategorySearchType' of XML schema type 'ns1:SearchType'
        enum ns1__SearchType *CategorySearchType;
        /// Optional element 'ns1:SubCategory' of XML schema type 'xsd:string'
        std::string *SubCategory;
        /// Optional element 'ns1:SubCategorySearchType' of XML schema type 'ns1:SearchType'
        enum ns1__SearchType *SubCategorySearchType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__EventFilter
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__EventFilter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__EventFilter, default initialized and not managed by a soap context
        virtual ns1__EventFilter *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__EventFilter); }
      public:
        /// Constructor with default initializations
        ns1__EventFilter() : OrganizerId(), VenueId(), KSBNumber(), LSBNumber(), SportRegion(), OnlyVisible(), OnlyWithEducationalLeave(), Title(), TitleSearchType(), TitleAddition(), TitleAdditionSearchType(), Subtitle(), SubtitleSearchType(), SubtitleAddition(), SubtitleAdditionSearchType(), Category(), CategorySearchType(), SubCategory(), SubCategorySearchType(), soap() { }
        virtual ~ns1__EventFilter() { }
        /// Friend allocator used by soap_new_ns1__EventFilter(struct soap*, int)
        friend SOAP_FMAC1 ns1__EventFilter * SOAP_FMAC2 soap_instantiate_ns1__EventFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bildung.h:170 */
#ifndef SOAP_TYPE_ns1__EventBase
#define SOAP_TYPE_ns1__EventBase (15)
/* Type ns1__EventBase is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'ns1:EventBase': */
class SOAP_CMAC ns1__EventBase {
      public:
        /// Required element 'ns1:Hidden' of XML schema type 'xsd:boolean'
        bool Hidden;
        /// Required element 'ns1:Id' of XML schema type 'xsd:unsignedInt'
        unsigned int Id;
        /// Required nillable (xsi:nil when NULL) element 'ns1:Number' of XML schema type 'xsd:string'
        std::string *Number;
        /// Required nillable (xsi:nil when NULL) element 'ns1:KSBNumber' of XML schema type 'xsd:string'
        std::string *KSBNumber;
        /// Required nillable (xsi:nil when NULL) element 'ns1:LSBNumber' of XML schema type 'xsd:string'
        std::string *LSBNumber;
        /// Required nillable (xsi:nil when NULL) element 'ns1:SportRegion' of XML schema type 'xsd:unsignedInt'
        unsigned int *SportRegion;
        /// Required nillable (xsi:nil when NULL) element 'ns1:Date' of XML schema type 'xsd:string'
        std::string *Date;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__EventBase
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__EventBase; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__EventBase, default initialized and not managed by a soap context
        virtual ns1__EventBase *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__EventBase); }
      public:
        /// Constructor with default initializations
        ns1__EventBase() : Hidden(), Id(), Number(), KSBNumber(), LSBNumber(), SportRegion(), Date(), soap() { }
        virtual ~ns1__EventBase() { }
        /// Friend allocator used by soap_new_ns1__EventBase(struct soap*, int)
        friend SOAP_FMAC1 ns1__EventBase * SOAP_FMAC2 soap_instantiate_ns1__EventBase(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bildung.h:174 */
#ifndef SOAP_TYPE_ns1__EventFee
#define SOAP_TYPE_ns1__EventFee (17)
/* complex XML schema type 'ns1:EventFee': */
class SOAP_CMAC ns1__EventFee {
      public:
        /// Optional element 'ns1:name' of XML schema type 'xsd:string'
        std::string *name;
        /// Required element 'ns1:fee' of XML schema type 'xsd:decimal'
        std::string fee;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__EventFee
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__EventFee; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__EventFee, default initialized and not managed by a soap context
        virtual ns1__EventFee *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__EventFee); }
      public:
        /// Constructor with default initializations
        ns1__EventFee() : name(), fee(), soap() { }
        virtual ~ns1__EventFee() { }
        /// Friend allocator used by soap_new_ns1__EventFee(struct soap*, int)
        friend SOAP_FMAC1 ns1__EventFee * SOAP_FMAC2 soap_instantiate_ns1__EventFee(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bildung.h:176 */
#ifndef SOAP_TYPE_ns1__Address
#define SOAP_TYPE_ns1__Address (18)
/* complex XML schema type 'ns1:Address': */
class SOAP_CMAC ns1__Address {
      public:
        /// Required nillable (xsi:nil when NULL) element 'ns1:Name' of XML schema type 'xsd:string'
        std::string *Name;
        /// Required nillable (xsi:nil when NULL) element 'ns1:Street' of XML schema type 'xsd:string'
        std::string *Street;
        /// Required nillable (xsi:nil when NULL) element 'ns1:Zip' of XML schema type 'xsd:string'
        std::string *Zip;
        /// Required nillable (xsi:nil when NULL) element 'ns1:City' of XML schema type 'xsd:string'
        std::string *City;
        /// Required nillable (xsi:nil when NULL) element 'ns1:Contact' of XML schema type 'xsd:string'
        std::string *Contact;
        /// Required nillable (xsi:nil when NULL) element 'ns1:Phone' of XML schema type 'xsd:string'
        std::string *Phone;
        /// Required nillable (xsi:nil when NULL) element 'ns1:Fax' of XML schema type 'xsd:string'
        std::string *Fax;
        /// Required nillable (xsi:nil when NULL) element 'ns1:MobilePhone' of XML schema type 'xsd:string'
        std::string *MobilePhone;
        /// Required nillable (xsi:nil when NULL) element 'ns1:EMail' of XML schema type 'xsd:string'
        std::string *EMail;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__Address
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__Address; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__Address, default initialized and not managed by a soap context
        virtual ns1__Address *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__Address); }
      public:
        /// Constructor with default initializations
        ns1__Address() : Name(), Street(), Zip(), City(), Contact(), Phone(), Fax(), MobilePhone(), EMail(), soap() { }
        virtual ~ns1__Address() { }
        /// Friend allocator used by soap_new_ns1__Address(struct soap*, int)
        friend SOAP_FMAC1 ns1__Address * SOAP_FMAC2 soap_instantiate_ns1__Address(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bildung.h:178 */
#ifndef SOAP_TYPE_ns1__WorkshopTimeslot
#define SOAP_TYPE_ns1__WorkshopTimeslot (19)
/* complex XML schema type 'ns1:WorkshopTimeslot': */
class SOAP_CMAC ns1__WorkshopTimeslot {
      public:
        /// Required nillable (xsi:nil when NULL) element 'ns1:Timeslot' of XML schema type 'xsd:string'
        std::string *Timeslot;
        /// Optional element 'ns1:Workshops' of XML schema type 'ns1:Workshop'
        std::vector<ns1__Workshop *> Workshops;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__WorkshopTimeslot
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__WorkshopTimeslot; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__WorkshopTimeslot, default initialized and not managed by a soap context
        virtual ns1__WorkshopTimeslot *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__WorkshopTimeslot); }
      public:
        /// Constructor with default initializations
        ns1__WorkshopTimeslot() : Timeslot(), Workshops(), soap() { }
        virtual ~ns1__WorkshopTimeslot() { }
        /// Friend allocator used by soap_new_ns1__WorkshopTimeslot(struct soap*, int)
        friend SOAP_FMAC1 ns1__WorkshopTimeslot * SOAP_FMAC2 soap_instantiate_ns1__WorkshopTimeslot(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bildung.h:180 */
#ifndef SOAP_TYPE_ns1__Workshop
#define SOAP_TYPE_ns1__Workshop (20)
/* complex XML schema type 'ns1:Workshop': */
class SOAP_CMAC ns1__Workshop {
      public:
        /// Required element 'ns1:Id' of XML schema type 'xsd:unsignedInt'
        unsigned int Id;
        /// Required nillable (xsi:nil when NULL) element 'ns1:Number' of XML schema type 'xsd:string'
        std::string *Number;
        /// Required nillable (xsi:nil when NULL) element 'ns1:Title' of XML schema type 'xsd:string'
        std::string *Title;
        /// Required nillable (xsi:nil when NULL) element 'ns1:AdditionalInfo' of XML schema type 'xsd:string'
        std::string *AdditionalInfo;
        /// Optional element 'ns1:Date' of XML schema type 'xsd:string'
        std::string *Date;
        /// Optional element 'ns1:TimeFrom' of XML schema type 'xsd:string'
        std::string *TimeFrom;
        /// Optional element 'ns1:TimeTo' of XML schema type 'xsd:string'
        std::string *TimeTo;
        /// Required element 'ns1:OccupancyPercentage' of XML schema type 'xsd:unsignedByte'
        unsigned char OccupancyPercentage;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__Workshop
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__Workshop; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__Workshop, default initialized and not managed by a soap context
        virtual ns1__Workshop *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__Workshop); }
      public:
        /// Constructor with default initializations
        ns1__Workshop() : Id(), Number(), Title(), AdditionalInfo(), Date(), TimeFrom(), TimeTo(), OccupancyPercentage(), soap() { }
        virtual ~ns1__Workshop() { }
        /// Friend allocator used by soap_new_ns1__Workshop(struct soap*, int)
        friend SOAP_FMAC1 ns1__Workshop * SOAP_FMAC2 soap_instantiate_ns1__Workshop(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bildung.h:182 */
#ifndef SOAP_TYPE_ns1__EventRegistration
#define SOAP_TYPE_ns1__EventRegistration (21)
/* complex XML schema type 'ns1:EventRegistration': */
class SOAP_CMAC ns1__EventRegistration {
      public:
        /// Optional element 'ns1:Events' of XML schema type 'ns1:EventRegistrationEvent'
        std::vector<ns1__EventRegistrationEvent *> Events;
        /// Required nillable (xsi:nil when NULL) element 'ns1:Salutation' of XML schema type 'xsd:string'
        std::string *Salutation;
        /// Required nillable (xsi:nil when NULL) element 'ns1:Title' of XML schema type 'xsd:string'
        std::string *Title;
        /// Required nillable (xsi:nil when NULL) element 'ns1:Firstname' of XML schema type 'xsd:string'
        std::string *Firstname;
        /// Required nillable (xsi:nil when NULL) element 'ns1:Lastname' of XML schema type 'xsd:string'
        std::string *Lastname;
        /// Required nillable (xsi:nil when NULL) element 'ns1:Street' of XML schema type 'xsd:string'
        std::string *Street;
        /// Required nillable (xsi:nil when NULL) element 'ns1:Zip' of XML schema type 'xsd:string'
        std::string *Zip;
        /// Required nillable (xsi:nil when NULL) element 'ns1:City' of XML schema type 'xsd:string'
        std::string *City;
        /// Required nillable (xsi:nil when NULL) element 'ns1:DateOfBirth' of XML schema type 'xsd:string'
        std::string *DateOfBirth;
        /// Required nillable (xsi:nil when NULL) element 'ns1:AccountHolder' of XML schema type 'xsd:string'
        std::string *AccountHolder;
        /// Required nillable (xsi:nil when NULL) element 'ns1:IBAN' of XML schema type 'xsd:string'
        std::string *IBAN;
        /// Required nillable (xsi:nil when NULL) element 'ns1:BIC' of XML schema type 'xsd:string'
        std::string *BIC;
        /// Required nillable (xsi:nil when NULL) element 'ns1:EMail' of XML schema type 'xsd:string'
        std::string *EMail;
        /// Required nillable (xsi:nil when NULL) element 'ns1:Phone' of XML schema type 'xsd:string'
        std::string *Phone;
        /// Required nillable (xsi:nil when NULL) element 'ns1:MobilePhone' of XML schema type 'xsd:string'
        std::string *MobilePhone;
        /// Required nillable (xsi:nil when NULL) element 'ns1:AssociationNumber' of XML schema type 'xsd:string'
        std::string *AssociationNumber;
        /// Required nillable (xsi:nil when NULL) element 'ns1:Association' of XML schema type 'xsd:string'
        std::string *Association;
        /// Required nillable (xsi:nil when NULL) element 'ns1:YouthLeaderCard' of XML schema type 'xsd:string'
        std::string *YouthLeaderCard;
        /// Required nillable (xsi:nil when NULL) element 'ns1:YouthLeaderCardValidity' of XML schema type 'xsd:string'
        std::string *YouthLeaderCardValidity;
        /// Required nillable (xsi:nil when NULL) element 'ns1:Comment' of XML schema type 'xsd:string'
        std::string *Comment;
        /// Required element 'ns1:Overnight' of XML schema type 'xsd:boolean'
        bool Overnight;
        /// Required element 'ns1:SingleRoom' of XML schema type 'xsd:boolean'
        bool SingleRoom;
        /// Required element 'ns1:Vegetarian' of XML schema type 'xsd:boolean'
        bool Vegetarian;
        /// Required element 'ns1:AddressDisclosure' of XML schema type 'xsd:boolean'
        bool AddressDisclosure;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__EventRegistration
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__EventRegistration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__EventRegistration, default initialized and not managed by a soap context
        virtual ns1__EventRegistration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__EventRegistration); }
      public:
        /// Constructor with default initializations
        ns1__EventRegistration() : Events(), Salutation(), Title(), Firstname(), Lastname(), Street(), Zip(), City(), DateOfBirth(), AccountHolder(), IBAN(), BIC(), EMail(), Phone(), MobilePhone(), AssociationNumber(), Association(), YouthLeaderCard(), YouthLeaderCardValidity(), Comment(), Overnight(), SingleRoom(), Vegetarian(), AddressDisclosure(), soap() { }
        virtual ~ns1__EventRegistration() { }
        /// Friend allocator used by soap_new_ns1__EventRegistration(struct soap*, int)
        friend SOAP_FMAC1 ns1__EventRegistration * SOAP_FMAC2 soap_instantiate_ns1__EventRegistration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bildung.h:184 */
#ifndef SOAP_TYPE_ns1__EventRegistrationEvent
#define SOAP_TYPE_ns1__EventRegistrationEvent (22)
/* complex XML schema type 'ns1:EventRegistrationEvent': */
class SOAP_CMAC ns1__EventRegistrationEvent {
      public:
        /// Required element 'ns1:Id' of XML schema type 'xsd:unsignedInt'
        unsigned int Id;
        /// Optional element 'ns1:WorkshopIds' of XML schema type 'xsd:unsignedInt'
        std::vector<unsigned int> WorkshopIds;
        /// Required nillable (xsi:nil when NULL) element 'ns1:WorkshopComment' of XML schema type 'xsd:string'
        std::string *WorkshopComment;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__EventRegistrationEvent
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__EventRegistrationEvent; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__EventRegistrationEvent, default initialized and not managed by a soap context
        virtual ns1__EventRegistrationEvent *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__EventRegistrationEvent); }
      public:
        /// Constructor with default initializations
        ns1__EventRegistrationEvent() : Id(), WorkshopIds(), WorkshopComment(), soap() { }
        virtual ~ns1__EventRegistrationEvent() { }
        /// Friend allocator used by soap_new_ns1__EventRegistrationEvent(struct soap*, int)
        friend SOAP_FMAC1 ns1__EventRegistrationEvent * SOAP_FMAC2 soap_instantiate_ns1__EventRegistrationEvent(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bildung.h:186 */
#ifndef SOAP_TYPE_ns1__EventRegistrationWarning
#define SOAP_TYPE_ns1__EventRegistrationWarning (23)
/* complex XML schema type 'ns1:EventRegistrationWarning': */
class SOAP_CMAC ns1__EventRegistrationWarning {
      public:
        /// Required element 'ns1:eventId' of XML schema type 'xsd:unsignedInt'
        unsigned int eventId;
        /// Required nillable (xsi:nil when NULL) element 'ns1:code' of XML schema type 'xsd:string'
        std::string *code;
        /// Required nillable (xsi:nil when NULL) element 'ns1:warningMessage' of XML schema type 'xsd:string'
        std::string *warningMessage;
        /// Optional element 'ns1:additionalData' of XML schema type 'ns1:KeyValue'
        std::vector<ns1__KeyValue *> additionalData;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__EventRegistrationWarning
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__EventRegistrationWarning; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__EventRegistrationWarning, default initialized and not managed by a soap context
        virtual ns1__EventRegistrationWarning *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__EventRegistrationWarning); }
      public:
        /// Constructor with default initializations
        ns1__EventRegistrationWarning() : eventId(), code(), warningMessage(), additionalData(), soap() { }
        virtual ~ns1__EventRegistrationWarning() { }
        /// Friend allocator used by soap_new_ns1__EventRegistrationWarning(struct soap*, int)
        friend SOAP_FMAC1 ns1__EventRegistrationWarning * SOAP_FMAC2 soap_instantiate_ns1__EventRegistrationWarning(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bildung.h:188 */
#ifndef SOAP_TYPE_ns1__KeyValue
#define SOAP_TYPE_ns1__KeyValue (24)
/* complex XML schema type 'ns1:KeyValue': */
class SOAP_CMAC ns1__KeyValue {
      public:
        /// Optional element 'ns1:key' of XML schema type 'xsd:string'
        std::string *key;
        /// Optional element 'ns1:value' of XML schema type 'xsd:string'
        std::string *value;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__KeyValue
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__KeyValue; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__KeyValue, default initialized and not managed by a soap context
        virtual ns1__KeyValue *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__KeyValue); }
      public:
        /// Constructor with default initializations
        ns1__KeyValue() : key(), value(), soap() { }
        virtual ~ns1__KeyValue() { }
        /// Friend allocator used by soap_new_ns1__KeyValue(struct soap*, int)
        friend SOAP_FMAC1 ns1__KeyValue * SOAP_FMAC2 soap_instantiate_ns1__KeyValue(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bildung.h:190 */
#ifndef SOAP_TYPE__ns1__dumpTableFields
#define SOAP_TYPE__ns1__dumpTableFields (25)
/* complex XML schema type 'ns1:dumpTableFields': */
class SOAP_CMAC _ns1__dumpTableFields {
      public:
        /// Optional element 'ns1:tableName' of XML schema type 'xsd:string'
        std::string *tableName;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__dumpTableFields
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__dumpTableFields; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__dumpTableFields, default initialized and not managed by a soap context
        virtual _ns1__dumpTableFields *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__dumpTableFields); }
      public:
        /// Constructor with default initializations
        _ns1__dumpTableFields() : tableName(), soap() { }
        virtual ~_ns1__dumpTableFields() { }
        /// Friend allocator used by soap_new__ns1__dumpTableFields(struct soap*, int)
        friend SOAP_FMAC1 _ns1__dumpTableFields * SOAP_FMAC2 soap_instantiate__ns1__dumpTableFields(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bildung.h:192 */
#ifndef SOAP_TYPE__ns1__dumpTableFieldsResponse
#define SOAP_TYPE__ns1__dumpTableFieldsResponse (26)
/* complex XML schema type 'ns1:dumpTableFieldsResponse': */
class SOAP_CMAC _ns1__dumpTableFieldsResponse {
      public:
        /// Optional element 'ns1:dumpTableFieldsResult' of XML schema type 'xsd:string'
        std::string *dumpTableFieldsResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__dumpTableFieldsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__dumpTableFieldsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__dumpTableFieldsResponse, default initialized and not managed by a soap context
        virtual _ns1__dumpTableFieldsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__dumpTableFieldsResponse); }
      public:
        /// Constructor with default initializations
        _ns1__dumpTableFieldsResponse() : dumpTableFieldsResult(), soap() { }
        virtual ~_ns1__dumpTableFieldsResponse() { }
        /// Friend allocator used by soap_new__ns1__dumpTableFieldsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__dumpTableFieldsResponse * SOAP_FMAC2 soap_instantiate__ns1__dumpTableFieldsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bildung.h:194 */
#ifndef SOAP_TYPE__ns1__getAllEvents
#define SOAP_TYPE__ns1__getAllEvents (27)
/* complex XML schema type 'ns1:getAllEvents': */
class SOAP_CMAC _ns1__getAllEvents {
      public:
        /// Required nillable (xsi:nil when NULL) element 'ns1:filter' of XML schema type 'ns1:EventFilter'
        ns1__EventFilter *filter;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getAllEvents
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__getAllEvents; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getAllEvents, default initialized and not managed by a soap context
        virtual _ns1__getAllEvents *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__getAllEvents); }
      public:
        /// Constructor with default initializations
        _ns1__getAllEvents() : filter(), soap() { }
        virtual ~_ns1__getAllEvents() { }
        /// Friend allocator used by soap_new__ns1__getAllEvents(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getAllEvents * SOAP_FMAC2 soap_instantiate__ns1__getAllEvents(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bildung.h:196 */
#ifndef SOAP_TYPE__ns1__getAllEventsResponse
#define SOAP_TYPE__ns1__getAllEventsResponse (28)
/* complex XML schema type 'ns1:getAllEventsResponse': */
class SOAP_CMAC _ns1__getAllEventsResponse {
      public:
        /// Optional element 'ns1:getAllEventsResult' of XML schema type 'ns1:EventMini'
        std::vector<ns1__EventMini *> getAllEventsResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getAllEventsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__getAllEventsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getAllEventsResponse, default initialized and not managed by a soap context
        virtual _ns1__getAllEventsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__getAllEventsResponse); }
      public:
        /// Constructor with default initializations
        _ns1__getAllEventsResponse() : getAllEventsResult(), soap() { }
        virtual ~_ns1__getAllEventsResponse() { }
        /// Friend allocator used by soap_new__ns1__getAllEventsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getAllEventsResponse * SOAP_FMAC2 soap_instantiate__ns1__getAllEventsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bildung.h:198 */
#ifndef SOAP_TYPE__ns1__getSingleEvent
#define SOAP_TYPE__ns1__getSingleEvent (29)
/* complex XML schema type 'ns1:getSingleEvent': */
class SOAP_CMAC _ns1__getSingleEvent {
      public:
        /// Required element 'ns1:id' of XML schema type 'xsd:unsignedInt'
        unsigned int id;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getSingleEvent
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__getSingleEvent; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getSingleEvent, default initialized and not managed by a soap context
        virtual _ns1__getSingleEvent *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__getSingleEvent); }
      public:
        /// Constructor with default initializations
        _ns1__getSingleEvent() : id(), soap() { }
        virtual ~_ns1__getSingleEvent() { }
        /// Friend allocator used by soap_new__ns1__getSingleEvent(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getSingleEvent * SOAP_FMAC2 soap_instantiate__ns1__getSingleEvent(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bildung.h:200 */
#ifndef SOAP_TYPE__ns1__getSingleEventResponse
#define SOAP_TYPE__ns1__getSingleEventResponse (30)
/* complex XML schema type 'ns1:getSingleEventResponse': */
class SOAP_CMAC _ns1__getSingleEventResponse {
      public:
        /// Optional element 'ns1:getSingleEventResult' of XML schema type 'ns1:Event'
        ns1__Event *getSingleEventResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getSingleEventResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__getSingleEventResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getSingleEventResponse, default initialized and not managed by a soap context
        virtual _ns1__getSingleEventResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__getSingleEventResponse); }
      public:
        /// Constructor with default initializations
        _ns1__getSingleEventResponse() : getSingleEventResult(), soap() { }
        virtual ~_ns1__getSingleEventResponse() { }
        /// Friend allocator used by soap_new__ns1__getSingleEventResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getSingleEventResponse * SOAP_FMAC2 soap_instantiate__ns1__getSingleEventResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bildung.h:202 */
#ifndef SOAP_TYPE__ns1__register
#define SOAP_TYPE__ns1__register (31)
/* complex XML schema type 'ns1:register': */
class SOAP_CMAC _ns1__register {
      public:
        /// Optional element 'ns1:registrationData' of XML schema type 'ns1:EventRegistration'
        ns1__EventRegistration *registrationData;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__register
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__register; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__register, default initialized and not managed by a soap context
        virtual _ns1__register *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__register); }
      public:
        /// Constructor with default initializations
        _ns1__register() : registrationData(), soap() { }
        virtual ~_ns1__register() { }
        /// Friend allocator used by soap_new__ns1__register(struct soap*, int)
        friend SOAP_FMAC1 _ns1__register * SOAP_FMAC2 soap_instantiate__ns1__register(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bildung.h:204 */
#ifndef SOAP_TYPE__ns1__registerResponse
#define SOAP_TYPE__ns1__registerResponse (32)
/* complex XML schema type 'ns1:registerResponse': */
class SOAP_CMAC _ns1__registerResponse {
      public:
        /// Optional element 'ns1:registerResult' of XML schema type 'ns1:EventRegistrationWarning'
        std::vector<ns1__EventRegistrationWarning *> registerResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__registerResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__registerResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__registerResponse, default initialized and not managed by a soap context
        virtual _ns1__registerResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__registerResponse); }
      public:
        /// Constructor with default initializations
        _ns1__registerResponse() : registerResult(), soap() { }
        virtual ~_ns1__registerResponse() { }
        /// Friend allocator used by soap_new__ns1__registerResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__registerResponse * SOAP_FMAC2 soap_instantiate__ns1__registerResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bildung.h:168 */
#ifndef SOAP_TYPE_ns1__EventMini
#define SOAP_TYPE_ns1__EventMini (14)
/* Type ns1__EventMini is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'ns1:EventMini': */
class SOAP_CMAC ns1__EventMini : public ns1__EventBase {
      public:
        /// Required nillable (xsi:nil when NULL) element 'ns1:Title' of XML schema type 'xsd:string'
        std::string *Title;
        /// Required nillable (xsi:nil when NULL) element 'ns1:TitleAddition' of XML schema type 'xsd:string'
        std::string *TitleAddition;
        /// Required nillable (xsi:nil when NULL) element 'ns1:Subtitle' of XML schema type 'xsd:string'
        std::string *Subtitle;
        /// Required nillable (xsi:nil when NULL) element 'ns1:SubtitleAddition' of XML schema type 'xsd:string'
        std::string *SubtitleAddition;
        /// Required nillable (xsi:nil when NULL) element 'ns1:Category' of XML schema type 'xsd:string'
        std::string *Category;
        /// Required nillable (xsi:nil when NULL) element 'ns1:SubCategory' of XML schema type 'xsd:string'
        std::string *SubCategory;
        /// Required nillable (xsi:nil when NULL) element 'ns1:Type' of XML schema type 'xsd:string'
        std::string *Type;
        /// Required nillable (xsi:nil when NULL) element 'ns1:VenueCity' of XML schema type 'xsd:string'
        std::string *VenueCity;
        /// Required element 'ns1:OccupancyPercentage' of XML schema type 'xsd:unsignedByte'
        unsigned char OccupancyPercentage;
        /// Required element 'ns1:EducationalLeave' of XML schema type 'xsd:boolean'
        bool EducationalLeave;
        /// Optional element 'ns1:SubEvents' of XML schema type 'ns1:EventBase'
        std::vector<ns1__EventBase *> SubEvents;
      public:
        /// Return unique type id SOAP_TYPE_ns1__EventMini
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__EventMini; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__EventMini, default initialized and not managed by a soap context
        virtual ns1__EventMini *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__EventMini); }
      public:
        /// Constructor with default initializations
        ns1__EventMini() : Title(), TitleAddition(), Subtitle(), SubtitleAddition(), Category(), SubCategory(), Type(), VenueCity(), OccupancyPercentage(), EducationalLeave(), SubEvents() { }
        virtual ~ns1__EventMini() { }
        /// Friend allocator used by soap_new_ns1__EventMini(struct soap*, int)
        friend SOAP_FMAC1 ns1__EventMini * SOAP_FMAC2 soap_instantiate_ns1__EventMini(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bildung.h:172 */
#ifndef SOAP_TYPE_ns1__Event
#define SOAP_TYPE_ns1__Event (16)
/* Type ns1__Event is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'ns1:Event': */
class SOAP_CMAC ns1__Event : public ns1__EventMini {
      public:
        /// Optional element 'ns1:EventFees' of XML schema type 'ns1:EventFee'
        std::vector<ns1__EventFee *> EventFees;
        /// Required nillable (xsi:nil when NULL) element 'ns1:Profile' of XML schema type 'xsd:string'
        std::string *Profile;
        /// Required nillable (xsi:nil when NULL) element 'ns1:Acknowledgement' of XML schema type 'xsd:string'
        std::string *Acknowledgement;
        /// Required nillable (xsi:nil when NULL) element 'ns1:TargetGroup' of XML schema type 'xsd:string'
        std::string *TargetGroup;
        /// Required element 'ns1:NumberOfLearnUnits' of XML schema type 'xsd:unsignedInt'
        unsigned int NumberOfLearnUnits;
        /// Optional element 'ns1:Venue' of XML schema type 'ns1:Address'
        ns1__Address *Venue;
        /// Required element 'ns1:VenueIsHandicappedAccessible' of XML schema type 'xsd:boolean'
        bool VenueIsHandicappedAccessible;
        /// Required nillable (xsi:nil when NULL) element 'ns1:Organizer' of XML schema type 'ns1:Address'
        ns1__Address *Organizer;
        /// Required nillable (xsi:nil when NULL) element 'ns1:InfoText' of XML schema type 'xsd:string'
        std::string *InfoText;
        /// Required nillable (xsi:nil when NULL) element 'ns1:InfoText2' of XML schema type 'xsd:string'
        std::string *InfoText2;
        /// Required nillable (xsi:nil when NULL) element 'ns1:InfoText3' of XML schema type 'xsd:string'
        std::string *InfoText3;
        /// Required nillable (xsi:nil when NULL) element 'ns1:InfoText4' of XML schema type 'xsd:string'
        std::string *InfoText4;
        /// Required nillable (xsi:nil when NULL) element 'ns1:InfoURL' of XML schema type 'xsd:string'
        std::string *InfoURL;
        /// Required nillable (xsi:nil when NULL) element 'ns1:MaxNumberOfWorkshopRegistrations' of XML schema type 'xsd:unsignedInt'
        unsigned int *MaxNumberOfWorkshopRegistrations;
        /// Optional element 'ns1:WorkshopTimeslots' of XML schema type 'ns1:WorkshopTimeslot'
        std::vector<ns1__WorkshopTimeslot *> WorkshopTimeslots;
      public:
        /// Return unique type id SOAP_TYPE_ns1__Event
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__Event; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__Event, default initialized and not managed by a soap context
        virtual ns1__Event *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__Event); }
      public:
        /// Constructor with default initializations
        ns1__Event() : EventFees(), Profile(), Acknowledgement(), TargetGroup(), NumberOfLearnUnits(), Venue(), VenueIsHandicappedAccessible(), Organizer(), InfoText(), InfoText2(), InfoText3(), InfoText4(), InfoURL(), MaxNumberOfWorkshopRegistrations(), WorkshopTimeslots() { }
        virtual ~ns1__Event() { }
        /// Friend allocator used by soap_new_ns1__Event(struct soap*, int)
        friend SOAP_FMAC1 ns1__Event * SOAP_FMAC2 soap_instantiate_ns1__Event(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bildung.h:1060 */
#ifndef SOAP_TYPE___ns1__dumpTableFields
#define SOAP_TYPE___ns1__dumpTableFields (64)
/* Wrapper: */
struct SOAP_CMAC __ns1__dumpTableFields {
      public:
        /** Optional element 'ns1:dumpTableFields' of XML schema type 'ns1:dumpTableFields' */
        _ns1__dumpTableFields *ns1__dumpTableFields;
      public:
        /** Return unique type id SOAP_TYPE___ns1__dumpTableFields */
        long soap_type() const { return SOAP_TYPE___ns1__dumpTableFields; }
        /** Constructor with member initializations */
        __ns1__dumpTableFields() : ns1__dumpTableFields() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__dumpTableFields * SOAP_FMAC2 soap_instantiate___ns1__dumpTableFields(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bildung.h:1130 */
#ifndef SOAP_TYPE___ns1__getAllEvents
#define SOAP_TYPE___ns1__getAllEvents (68)
/* Wrapper: */
struct SOAP_CMAC __ns1__getAllEvents {
      public:
        /** Optional element 'ns1:getAllEvents' of XML schema type 'ns1:getAllEvents' */
        _ns1__getAllEvents *ns1__getAllEvents;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getAllEvents */
        long soap_type() const { return SOAP_TYPE___ns1__getAllEvents; }
        /** Constructor with member initializations */
        __ns1__getAllEvents() : ns1__getAllEvents() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getAllEvents * SOAP_FMAC2 soap_instantiate___ns1__getAllEvents(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bildung.h:1200 */
#ifndef SOAP_TYPE___ns1__getSingleEvent
#define SOAP_TYPE___ns1__getSingleEvent (72)
/* Wrapper: */
struct SOAP_CMAC __ns1__getSingleEvent {
      public:
        /** Optional element 'ns1:getSingleEvent' of XML schema type 'ns1:getSingleEvent' */
        _ns1__getSingleEvent *ns1__getSingleEvent;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getSingleEvent */
        long soap_type() const { return SOAP_TYPE___ns1__getSingleEvent; }
        /** Constructor with member initializations */
        __ns1__getSingleEvent() : ns1__getSingleEvent() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getSingleEvent * SOAP_FMAC2 soap_instantiate___ns1__getSingleEvent(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bildung.h:1270 */
#ifndef SOAP_TYPE___ns1__register
#define SOAP_TYPE___ns1__register (76)
/* Wrapper: */
struct SOAP_CMAC __ns1__register {
      public:
        /** Optional element 'ns1:register' of XML schema type 'ns1:register' */
        _ns1__register *ns1__register;
      public:
        /** Return unique type id SOAP_TYPE___ns1__register */
        long soap_type() const { return SOAP_TYPE___ns1__register; }
        /** Constructor with member initializations */
        __ns1__register() : ns1__register() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__register * SOAP_FMAC2 soap_instantiate___ns1__register(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bildung.h:1340 */
#ifndef SOAP_TYPE___ns1__dumpTableFields_
#define SOAP_TYPE___ns1__dumpTableFields_ (78)
/* Wrapper: */
struct SOAP_CMAC __ns1__dumpTableFields_ {
      public:
        /** Optional element 'ns1:dumpTableFields' of XML schema type 'ns1:dumpTableFields' */
        _ns1__dumpTableFields *ns1__dumpTableFields;
      public:
        /** Return unique type id SOAP_TYPE___ns1__dumpTableFields_ */
        long soap_type() const { return SOAP_TYPE___ns1__dumpTableFields_; }
        /** Constructor with member initializations */
        __ns1__dumpTableFields_() : ns1__dumpTableFields() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__dumpTableFields_ * SOAP_FMAC2 soap_instantiate___ns1__dumpTableFields_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bildung.h:1410 */
#ifndef SOAP_TYPE___ns1__getAllEvents_
#define SOAP_TYPE___ns1__getAllEvents_ (80)
/* Wrapper: */
struct SOAP_CMAC __ns1__getAllEvents_ {
      public:
        /** Optional element 'ns1:getAllEvents' of XML schema type 'ns1:getAllEvents' */
        _ns1__getAllEvents *ns1__getAllEvents;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getAllEvents_ */
        long soap_type() const { return SOAP_TYPE___ns1__getAllEvents_; }
        /** Constructor with member initializations */
        __ns1__getAllEvents_() : ns1__getAllEvents() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getAllEvents_ * SOAP_FMAC2 soap_instantiate___ns1__getAllEvents_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bildung.h:1480 */
#ifndef SOAP_TYPE___ns1__getSingleEvent_
#define SOAP_TYPE___ns1__getSingleEvent_ (82)
/* Wrapper: */
struct SOAP_CMAC __ns1__getSingleEvent_ {
      public:
        /** Optional element 'ns1:getSingleEvent' of XML schema type 'ns1:getSingleEvent' */
        _ns1__getSingleEvent *ns1__getSingleEvent;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getSingleEvent_ */
        long soap_type() const { return SOAP_TYPE___ns1__getSingleEvent_; }
        /** Constructor with member initializations */
        __ns1__getSingleEvent_() : ns1__getSingleEvent() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getSingleEvent_ * SOAP_FMAC2 soap_instantiate___ns1__getSingleEvent_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bildung.h:1550 */
#ifndef SOAP_TYPE___ns1__register_
#define SOAP_TYPE___ns1__register_ (84)
/* Wrapper: */
struct SOAP_CMAC __ns1__register_ {
      public:
        /** Optional element 'ns1:register' of XML schema type 'ns1:register' */
        _ns1__register *ns1__register;
      public:
        /** Return unique type id SOAP_TYPE___ns1__register_ */
        long soap_type() const { return SOAP_TYPE___ns1__register_; }
        /** Constructor with member initializations */
        __ns1__register_() : ns1__register() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__register_ * SOAP_FMAC2 soap_instantiate___ns1__register_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* bildung.h:1731 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (85)
/* SOAP_ENV__Header: */
struct SOAP_CMAC SOAP_ENV__Header {
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Header */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* bildung.h:1731 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (86)
/* Type SOAP_ENV__Code is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* SOAP_ENV__Code: */
struct SOAP_CMAC SOAP_ENV__Code {
      public:
        /** Optional element 'SOAP-ENV:Value' of XML schema type 'xsd:QName' */
        char *SOAP_ENV__Value;
        /** Optional element 'SOAP-ENV:Subcode' of XML schema type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Subcode;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Code */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Code; }
        /** Constructor with member initializations */
        SOAP_ENV__Code() : SOAP_ENV__Value(), SOAP_ENV__Subcode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* bildung.h:1731 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (88)
/* SOAP_ENV__Detail: */
struct SOAP_CMAC SOAP_ENV__Detail {
      public:
        char *__any;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_<typename> assigned to __type */
        /** Do not create a cyclic data structure through this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Detail */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail() : __any(), __type(), fault() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* bildung.h:1731 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (91)
/* SOAP_ENV__Reason: */
struct SOAP_CMAC SOAP_ENV__Reason {
      public:
        /** Optional element 'SOAP-ENV:Text' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Text;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Reason */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Reason; }
        /** Constructor with member initializations */
        SOAP_ENV__Reason() : SOAP_ENV__Text() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* bildung.h:1731 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (92)
/* SOAP_ENV__Fault: */
struct SOAP_CMAC SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XML schema type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XML schema type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XML schema type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XML schema type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XML schema type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Fault */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault() : faultcode(), faultstring(), faultactor(), detail(), SOAP_ENV__Code(), SOAP_ENV__Reason(), SOAP_ENV__Node(), SOAP_ENV__Role(), SOAP_ENV__Detail() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* (built-in):0 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
typedef char *_XML;
#endif

/* (built-in):0 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
typedef char *_QName;
#endif

/* bildung.h:153 */
#ifndef SOAP_TYPE_xsd__unsignedByte
#define SOAP_TYPE_xsd__unsignedByte (10)
typedef unsigned char xsd__unsignedByte;
#endif

/* bildung.h:156 */
#ifndef SOAP_TYPE_xsd__decimal
#define SOAP_TYPE_xsd__decimal (12)
typedef std::string xsd__decimal;
#endif

/******************************************************************************\
 *                                                                            *
 * Serializable Types                                                         *
 *                                                                            *
\******************************************************************************/


/* char has binding name 'byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_byte
#define SOAP_TYPE_byte (3)
#endif

/* int has binding name 'int' for type 'xsd:int' */
#ifndef SOAP_TYPE_int
#define SOAP_TYPE_int (1)
#endif

/* xsd__unsignedByte has binding name 'xsd__unsignedByte' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_xsd__unsignedByte
#define SOAP_TYPE_xsd__unsignedByte (10)
#endif

/* unsigned char has binding name 'unsignedByte' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_unsignedByte
#define SOAP_TYPE_unsignedByte (9)
#endif

/* unsigned int has binding name 'unsignedInt' for type 'xsd:unsignedInt' */
#ifndef SOAP_TYPE_unsignedInt
#define SOAP_TYPE_unsignedInt (8)
#endif

/* bool has binding name 'bool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_bool
#define SOAP_TYPE_bool (36)
#endif

/* enum ns1__SearchType has binding name 'ns1__SearchType' for type 'ns1:SearchType' */
#ifndef SOAP_TYPE_ns1__SearchType
#define SOAP_TYPE_ns1__SearchType (33)
#endif

/* _ns1__registerResponse has binding name '_ns1__registerResponse' for type '' */
#ifndef SOAP_TYPE__ns1__registerResponse
#define SOAP_TYPE__ns1__registerResponse (32)
#endif

/* _ns1__register has binding name '_ns1__register' for type '' */
#ifndef SOAP_TYPE__ns1__register
#define SOAP_TYPE__ns1__register (31)
#endif

/* _ns1__getSingleEventResponse has binding name '_ns1__getSingleEventResponse' for type '' */
#ifndef SOAP_TYPE__ns1__getSingleEventResponse
#define SOAP_TYPE__ns1__getSingleEventResponse (30)
#endif

/* _ns1__getSingleEvent has binding name '_ns1__getSingleEvent' for type '' */
#ifndef SOAP_TYPE__ns1__getSingleEvent
#define SOAP_TYPE__ns1__getSingleEvent (29)
#endif

/* _ns1__getAllEventsResponse has binding name '_ns1__getAllEventsResponse' for type '' */
#ifndef SOAP_TYPE__ns1__getAllEventsResponse
#define SOAP_TYPE__ns1__getAllEventsResponse (28)
#endif

/* _ns1__getAllEvents has binding name '_ns1__getAllEvents' for type '' */
#ifndef SOAP_TYPE__ns1__getAllEvents
#define SOAP_TYPE__ns1__getAllEvents (27)
#endif

/* _ns1__dumpTableFieldsResponse has binding name '_ns1__dumpTableFieldsResponse' for type '' */
#ifndef SOAP_TYPE__ns1__dumpTableFieldsResponse
#define SOAP_TYPE__ns1__dumpTableFieldsResponse (26)
#endif

/* _ns1__dumpTableFields has binding name '_ns1__dumpTableFields' for type '' */
#ifndef SOAP_TYPE__ns1__dumpTableFields
#define SOAP_TYPE__ns1__dumpTableFields (25)
#endif

/* ns1__KeyValue has binding name 'ns1__KeyValue' for type 'ns1:KeyValue' */
#ifndef SOAP_TYPE_ns1__KeyValue
#define SOAP_TYPE_ns1__KeyValue (24)
#endif

/* ns1__EventRegistrationWarning has binding name 'ns1__EventRegistrationWarning' for type 'ns1:EventRegistrationWarning' */
#ifndef SOAP_TYPE_ns1__EventRegistrationWarning
#define SOAP_TYPE_ns1__EventRegistrationWarning (23)
#endif

/* ns1__EventRegistrationEvent has binding name 'ns1__EventRegistrationEvent' for type 'ns1:EventRegistrationEvent' */
#ifndef SOAP_TYPE_ns1__EventRegistrationEvent
#define SOAP_TYPE_ns1__EventRegistrationEvent (22)
#endif

/* ns1__EventRegistration has binding name 'ns1__EventRegistration' for type 'ns1:EventRegistration' */
#ifndef SOAP_TYPE_ns1__EventRegistration
#define SOAP_TYPE_ns1__EventRegistration (21)
#endif

/* ns1__Workshop has binding name 'ns1__Workshop' for type 'ns1:Workshop' */
#ifndef SOAP_TYPE_ns1__Workshop
#define SOAP_TYPE_ns1__Workshop (20)
#endif

/* ns1__WorkshopTimeslot has binding name 'ns1__WorkshopTimeslot' for type 'ns1:WorkshopTimeslot' */
#ifndef SOAP_TYPE_ns1__WorkshopTimeslot
#define SOAP_TYPE_ns1__WorkshopTimeslot (19)
#endif

/* ns1__Address has binding name 'ns1__Address' for type 'ns1:Address' */
#ifndef SOAP_TYPE_ns1__Address
#define SOAP_TYPE_ns1__Address (18)
#endif

/* ns1__EventFee has binding name 'ns1__EventFee' for type 'ns1:EventFee' */
#ifndef SOAP_TYPE_ns1__EventFee
#define SOAP_TYPE_ns1__EventFee (17)
#endif

/* ns1__Event has binding name 'ns1__Event' for type 'ns1:Event' */
#ifndef SOAP_TYPE_ns1__Event
#define SOAP_TYPE_ns1__Event (16)
#endif

/* ns1__EventBase has binding name 'ns1__EventBase' for type 'ns1:EventBase' */
#ifndef SOAP_TYPE_ns1__EventBase
#define SOAP_TYPE_ns1__EventBase (15)
#endif

/* ns1__EventMini has binding name 'ns1__EventMini' for type 'ns1:EventMini' */
#ifndef SOAP_TYPE_ns1__EventMini
#define SOAP_TYPE_ns1__EventMini (14)
#endif

/* ns1__EventFilter has binding name 'ns1__EventFilter' for type 'ns1:EventFilter' */
#ifndef SOAP_TYPE_ns1__EventFilter
#define SOAP_TYPE_ns1__EventFilter (13)
#endif

/* xsd__decimal has binding name 'xsd__decimal' for type 'xsd:decimal' */
#ifndef SOAP_TYPE_xsd__decimal
#define SOAP_TYPE_xsd__decimal (12)
#endif

/* std::string has binding name 'std__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__string
#define SOAP_TYPE_std__string (11)
#endif

/* struct SOAP_ENV__Fault has binding name 'SOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (92)
#endif

/* struct SOAP_ENV__Reason has binding name 'SOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (91)
#endif

/* struct SOAP_ENV__Detail has binding name 'SOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (88)
#endif

/* struct SOAP_ENV__Code has binding name 'SOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (86)
#endif

/* struct SOAP_ENV__Header has binding name 'SOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (85)
#endif

/* struct SOAP_ENV__Reason * has binding name 'PointerToSOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason
#define SOAP_TYPE_PointerToSOAP_ENV__Reason (94)
#endif

/* struct SOAP_ENV__Detail * has binding name 'PointerToSOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail
#define SOAP_TYPE_PointerToSOAP_ENV__Detail (93)
#endif

/* struct SOAP_ENV__Code * has binding name 'PointerToSOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code
#define SOAP_TYPE_PointerToSOAP_ENV__Code (87)
#endif

/* _ns1__register * has binding name 'PointerTo_ns1__register' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__register
#define SOAP_TYPE_PointerTo_ns1__register (73)
#endif

/* _ns1__getSingleEvent * has binding name 'PointerTo_ns1__getSingleEvent' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__getSingleEvent
#define SOAP_TYPE_PointerTo_ns1__getSingleEvent (69)
#endif

/* _ns1__getAllEvents * has binding name 'PointerTo_ns1__getAllEvents' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__getAllEvents
#define SOAP_TYPE_PointerTo_ns1__getAllEvents (65)
#endif

/* _ns1__dumpTableFields * has binding name 'PointerTo_ns1__dumpTableFields' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__dumpTableFields
#define SOAP_TYPE_PointerTo_ns1__dumpTableFields (61)
#endif

/* ns1__WorkshopTimeslot * has binding name 'PointerTons1__WorkshopTimeslot' for type 'ns1:WorkshopTimeslot' */
#ifndef SOAP_TYPE_PointerTons1__WorkshopTimeslot
#define SOAP_TYPE_PointerTons1__WorkshopTimeslot (59)
#endif

/* ns1__Address * has binding name 'PointerTons1__Address' for type 'ns1:Address' */
#ifndef SOAP_TYPE_PointerTons1__Address
#define SOAP_TYPE_PointerTons1__Address (58)
#endif

/* ns1__EventFee * has binding name 'PointerTons1__EventFee' for type 'ns1:EventFee' */
#ifndef SOAP_TYPE_PointerTons1__EventFee
#define SOAP_TYPE_PointerTons1__EventFee (56)
#endif

/* ns1__EventBase * has binding name 'PointerTons1__EventBase' for type 'ns1:EventBase' */
#ifndef SOAP_TYPE_PointerTons1__EventBase
#define SOAP_TYPE_PointerTons1__EventBase (54)
#endif

/* ns1__EventRegistrationWarning * has binding name 'PointerTons1__EventRegistrationWarning' for type 'ns1:EventRegistrationWarning' */
#ifndef SOAP_TYPE_PointerTons1__EventRegistrationWarning
#define SOAP_TYPE_PointerTons1__EventRegistrationWarning (52)
#endif

/* ns1__EventRegistration * has binding name 'PointerTons1__EventRegistration' for type 'ns1:EventRegistration' */
#ifndef SOAP_TYPE_PointerTons1__EventRegistration
#define SOAP_TYPE_PointerTons1__EventRegistration (51)
#endif

/* ns1__Event * has binding name 'PointerTons1__Event' for type 'ns1:Event' */
#ifndef SOAP_TYPE_PointerTons1__Event
#define SOAP_TYPE_PointerTons1__Event (50)
#endif

/* ns1__EventMini * has binding name 'PointerTons1__EventMini' for type 'ns1:EventMini' */
#ifndef SOAP_TYPE_PointerTons1__EventMini
#define SOAP_TYPE_PointerTons1__EventMini (48)
#endif

/* ns1__EventFilter * has binding name 'PointerTons1__EventFilter' for type 'ns1:EventFilter' */
#ifndef SOAP_TYPE_PointerTons1__EventFilter
#define SOAP_TYPE_PointerTons1__EventFilter (47)
#endif

/* ns1__KeyValue * has binding name 'PointerTons1__KeyValue' for type 'ns1:KeyValue' */
#ifndef SOAP_TYPE_PointerTons1__KeyValue
#define SOAP_TYPE_PointerTons1__KeyValue (45)
#endif

/* ns1__EventRegistrationEvent * has binding name 'PointerTons1__EventRegistrationEvent' for type 'ns1:EventRegistrationEvent' */
#ifndef SOAP_TYPE_PointerTons1__EventRegistrationEvent
#define SOAP_TYPE_PointerTons1__EventRegistrationEvent (42)
#endif

/* ns1__Workshop * has binding name 'PointerTons1__Workshop' for type 'ns1:Workshop' */
#ifndef SOAP_TYPE_PointerTons1__Workshop
#define SOAP_TYPE_PointerTons1__Workshop (40)
#endif

/* enum ns1__SearchType * has binding name 'PointerTons1__SearchType' for type 'ns1:SearchType' */
#ifndef SOAP_TYPE_PointerTons1__SearchType
#define SOAP_TYPE_PointerTons1__SearchType (38)
#endif

/* bool * has binding name 'PointerTobool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_PointerTobool
#define SOAP_TYPE_PointerTobool (37)
#endif

/* std::string * has binding name 'PointerTostd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_PointerTostd__string
#define SOAP_TYPE_PointerTostd__string (35)
#endif

/* unsigned int * has binding name 'PointerTounsignedInt' for type 'xsd:unsignedInt' */
#ifndef SOAP_TYPE_PointerTounsignedInt
#define SOAP_TYPE_PointerTounsignedInt (34)
#endif

/* _QName has binding name '_QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
#endif

/* _XML has binding name '_XML' for type '' */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
#endif

/* char * has binding name 'string' for type 'xsd:string' */
#ifndef SOAP_TYPE_string
#define SOAP_TYPE_string (4)
#endif

/* std::vector<ns1__WorkshopTimeslot *>  has binding name 'std__vectorTemplateOfPointerTons1__WorkshopTimeslot' for type 'ns1:WorkshopTimeslot' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__WorkshopTimeslot
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__WorkshopTimeslot (60)
#endif

/* std::vector<ns1__EventFee *>  has binding name 'std__vectorTemplateOfPointerTons1__EventFee' for type 'ns1:EventFee' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__EventFee
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__EventFee (57)
#endif

/* std::vector<ns1__EventBase *>  has binding name 'std__vectorTemplateOfPointerTons1__EventBase' for type 'ns1:EventBase' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__EventBase
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__EventBase (55)
#endif

/* std::vector<ns1__EventRegistrationWarning *>  has binding name 'std__vectorTemplateOfPointerTons1__EventRegistrationWarning' for type 'ns1:EventRegistrationWarning' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__EventRegistrationWarning
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__EventRegistrationWarning (53)
#endif

/* std::vector<ns1__EventMini *>  has binding name 'std__vectorTemplateOfPointerTons1__EventMini' for type 'ns1:EventMini' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__EventMini
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__EventMini (49)
#endif

/* std::vector<ns1__KeyValue *>  has binding name 'std__vectorTemplateOfPointerTons1__KeyValue' for type 'ns1:KeyValue' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__KeyValue
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__KeyValue (46)
#endif

/* std::vector<unsigned int>  has binding name 'std__vectorTemplateOfunsignedInt' for type 'xsd:unsignedInt' */
#ifndef SOAP_TYPE_std__vectorTemplateOfunsignedInt
#define SOAP_TYPE_std__vectorTemplateOfunsignedInt (44)
#endif

/* std::vector<ns1__EventRegistrationEvent *>  has binding name 'std__vectorTemplateOfPointerTons1__EventRegistrationEvent' for type 'ns1:EventRegistrationEvent' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__EventRegistrationEvent
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__EventRegistrationEvent (43)
#endif

/* std::vector<ns1__Workshop *>  has binding name 'std__vectorTemplateOfPointerTons1__Workshop' for type 'ns1:Workshop' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__Workshop
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__Workshop (41)
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
